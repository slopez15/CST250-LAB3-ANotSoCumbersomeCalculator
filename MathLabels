# main source file

.org 0x10000000

li $sp , 0x10fffffc # load stack pointer with memory location

li $t2, 0x2b #operator 0x2b ‘+’
beq $t1, $t2, addt #in meth() pop 2 vals, do operation, push result
nop

li $t2, 0x2d #operator 0x2d ‘-’
beq $t1, $t2, subt #in meth() pop 2 vals, do operation, push result
nop

li $t2, 0x2a #operator 0x2a ‘*’
beq $t1, $t2, mult #in meth() pop 2 vals, do operation, push result
nop

li $t2, 0x2f #operator 0x2f ‘/’
beq $t1, $t2, divWorks #in meth() pop 2 vals, do operation, push result
nop

li $t2, 0x3d #operator 0x3d ‘=’
beq $t1, $t2, equals #in meth() pop 2 vals, do operation, push result
nop

li $t2, 0x20 #operator 0x20 ‘_’<=space
beq $t1, $t2, delimiter #in meth() pop 2 vals, do operation, push result
nop

li $t2, 0x6e #operator 0x6e ‘n’
beq $t1, $t2, negate
nop

addt:
pop $t6
pop $t7
addu $t6, $t7, $t6
push $t6
nop

subt:
pop $t6
pop $t7
subu $t6, $t7,$t6
push $t6
nop

mult:
pop $t6
pop $t7
mullo $t6, $t7,$t6
push $t6
nop 

divWorks:
pop $t6
pop $t7
move $t6, $a1
move $t7, $a0
call divide
push $v0

delimiter:

equals:

negate:
subu $t6, $0, $t6
push $t6
nop


end:
j end
nop


#START DIVIDE
divide:
# expects dividend in $a0
# expects divisor in $a1
# stores quotient in $v0
# stores remainder in $v1
# will overwrite temporary registers
move $t0 , $a0	# move values to temp register
move $t1 , $a1	# move values to temp register
ori $t4 , $zero , 0x0	# load count value
ori $t9 , $zero , 0x1

div:
slt $t3 , $t0 , $t1	# divide by subtraction
beq $t9 , $t3 , ret	# jump if remainder is less than quotient
nop
	# nop after jump
subu $t0 , $t0 , $t1	# subtract
addu $t4 , $t4 , $t9	# increment counter
j div	# jump to top again
nop	# nop after jump

ret:
move $v0 , $t4	# move quotient to $v0
move $v1 , $t0	# move remainder to $v1

return	# returns from divide call
# END DIVIDE
